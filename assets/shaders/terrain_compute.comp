#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D heightMap;

layout(std430, binding = 1) buffer VertexBuffer {
    vec3 vertices[];
};

layout(std430, binding = 2) buffer TexCoordBuffer {
    vec2 texCoords[];
};

layout(std430, binding = 3) buffer IndexBuffer {
    uint indices[];
};

uniform int width;
uniform int height;

void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    
    if (gid.x >= width || gid.y >= height) return;

    // Reading height value from the height map texture
    float heightValue = imageLoad(heightMap, gid).r;

    // Normalize height value assuming height map is stored as normalized [0, 1] in red channel
    float yScale = 256.0f;
    float yShift = 16.0f;
    float yy = heightValue * yScale - yShift;
    float xx = -height / 2.0f + gid.y;
    float zz = -width / 2.0f + gid.x;

    // Store vertex positions
    uint idx = gid.y * width + gid.x;
    vertices[idx] = vec3(xx, yy, zz);

    // Store texture coordinates
    texCoords[idx] = vec2(float(gid.x) / float(width - 1), float(gid.y) / float(height - 1));

    // Calculate indices for mesh topology (e.g., triangle strip)
    if (gid.x < width - 1 && gid.y < height - 1) {
        uint baseIdx = gid.y * width + gid.x;
        indices[baseIdx * 6 + 0] = baseIdx;
        indices[baseIdx * 6 + 1] = baseIdx + 1;
        indices[baseIdx * 6 + 2] = baseIdx + width;

        indices[baseIdx * 6 + 3] = baseIdx + 1;
        indices[baseIdx * 6 + 4] = baseIdx + 1 + width;
        indices[baseIdx * 6 + 5] = baseIdx + width;
    }
}
